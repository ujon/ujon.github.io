"use strict";(self.webpackChunkujon_github_io=self.webpackChunkujon_github_io||[]).push([[130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"20251226__qr_order","metadata":{"permalink":"/blog/20251226__qr_order","source":"@site/blog/20251226/index.md","title":"[System Design] QR Order","description":"Overview","date":"2025-12-26T00:00:00.000Z","tags":[{"inline":false,"label":"System Design","permalink":"/blog/tags/system-design"}],"readingTime":1.63,"hasTruncateMarker":false,"authors":[{"name":"ujon","key":null,"page":null}],"frontMatter":{"slug":"20251226__qr_order","title":"[System Design] QR Order","author":"ujon","date":"2025-12-26T00:00:00.000Z","tags":["system-design"]},"unlisted":false,"nextItem":{"title":"[Project Structure] Spring Boot","permalink":"/blog/20251201__project_structure__spring_boot"}},"content":"## Overview\\n\\nDuring a trip to the US, I had a great experience using a QR code ordering and payment system at a restaurant. Recently, I encountered the same system at a restaurant in Korea during lunch and decided to design it myself.\\n\\n## Requirements\\n\\n- Customers can place orders by scanning a QR code\\n- Each table has a unique QR code\\n- Multiple customers at the same table can share a cart in real-time and order together\\n- The kitchen can immediately view completed orders\\n- Orders cannot be placed from outside the restaurant\\n\\n## System Design\\n\\n![system design](/asset/image/20251226_qr_order.png)\\n\\n### Websocket Server\\n\\nHandles real-time communication and runs as a separate instance from the Client API and Admin API for load distribution.\\n\\n**Key Features**\\n\\n- Real-time cart synchronization between customers at the same table\\n- Order notifications to kitchen devices\\n\\n**Implementation**\\n\\n- Cart Synchronization\\n  - Uses Redis Pub/Sub to manage channels and support horizontal scaling.\\n  - Pub/Sub does not persist messages, which means there is a possibility of message loss. However, since cart data is ephemeral and can be re-synced during order confirmation, Streams is not used.\\n- Order Processing\\n  - Uses Redis Streams to ensure orders are reliably delivered to the kitchen.\\n  - Implements Consumer Groups to enable reprocessing in case of failures.\\n\\n### Client API\\n\\nProvides APIs for customers.\\n\\n**Key Features**\\n\\n- Menu listing\\n- Order submission\\n\\n**Implementation**\\n\\n- Order Submission\\n  - Validates menu item consistency upon order submission. Applies Optimistic Locking to handle concurrency issues when menu items have limited availability.\\n  - Produces order messages to Redis Streams so the kitchen can receive them.\\n\\n**Security Considerations**\\n\\nThe following validation logic is required to block orders from outside the restaurant:\\n\\n- Client IP validation (verify the request originates from the restaurant\'s network)\\n- GPS coordinate validation (calculate distance from the restaurant\'s location)\\n- Combination of both conditions to prevent bypass attempts\\n\\n### Admin API\\n\\nProvides APIs for restaurant owners and staff.\\n\\n**Key Features**\\n\\n- Menu registration and management\\n- Table-specific billing summary\\n- Order status management\\n\\n## Sequence Diagram\\n\\n![sequencediagram](/asset/image/20251226_order_sq.svg)"},{"id":"20251201__project_structure__spring_boot","metadata":{"permalink":"/blog/20251201__project_structure__spring_boot","source":"@site/blog/20251218/index.md","title":"[Project Structure] Spring Boot","description":"While working on personal projects, I have organized the project structure and architectural conventions that I frequently use in multi-module Spring Boot projects.","date":"2025-12-18T00:00:00.000Z","tags":[{"inline":false,"label":"Project Structure","permalink":"/blog/tags/project-structure"}],"readingTime":7.46,"hasTruncateMarker":false,"authors":[{"name":"ujon","key":null,"page":null}],"frontMatter":{"slug":"20251201__project_structure__spring_boot","title":"[Project Structure] Spring Boot","author":"ujon","date":"2025-12-18T00:00:00.000Z","tags":["project-structure"]},"unlisted":false,"prevItem":{"title":"[System Design] QR Order","permalink":"/blog/20251226__qr_order"}},"content":"While working on personal projects, I have organized the project structure and architectural conventions that I frequently use in multi-module Spring Boot projects.\\nThis structure is designed based on a Layered Architecture inspired by Domain-Driven Design(DDD) concepts.\\n\\n## Project Structure\\n\\n```text\\n{project}-server/\\n\u251c\u2500\u2500 .data/\\n\u251c\u2500\u2500 .docs/\\n\u251c\u2500\u2500 .infra/\\n\u2502   \u251c\u2500\u2500 database/\\n\u2502   \u2502   \u251c\u2500\u2500 migrations/\\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 v0.0.1__example.sql\\n\u2502   \u2502   \u2514\u2500\u2500 flyway.local.conf\\n\u2502   \u251c\u2500\u2500 env/\\n\u2502   \u2502   \u2514\u2500\u2500 .env.local\\n\u2502   \u251c\u2500\u2500 terraform/\\n\u2502   \u2502   \u251c\u2500\u2500 environments/\\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 {environment}/\\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 main.tf\\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 variable.tf\\n\u2502   \u2502   \u2514\u2500\u2500 modules/\\n\u2502   \u2514\u2500\u2500 docker-compose.yml\\n\u251c\u2500\u2500 gradle\\n\u2502   \u2514\u2500\u2500 libs.versions.toml\\n\u251c\u2500\u2500 {project}-api/\\n\u2502   \u2514\u2500\u2500 src/main/kotlin/{project}/api\\n\u2502           \u251c\u2500\u2500 common/\\n\u2502           \u251c\u2500\u2500 {path}/\\n\u2502           \u2502   \u251c\u2500\u2500 request/\\n\u2502           \u2502   \u251c\u2500\u2500 response/\\n\u2502           \u2502   \u251c\u2500\u2500 {path}Controller.kt\\n\u2502           \u2502   \u251c\u2500\u2500 {path}Facade.kt\\n\u2502           \u2502   \u2514\u2500\u2500 {path}FacadeImpl.kt\\n\u2502           \u2514\u2500\u2500 {project}Api.kt\\n\u251c\u2500\u2500 {project}-admin-api/\\n\u251c\u2500\u2500 {project}-batch/\\n\u2502   \u2514\u2500\u2500 src/main/kotlin/{project}/batch\\n\u2502           \u251c\u2500\u2500 common/\\n\u2502           \u251c\u2500\u2500 job/\\n\u2502           \u251c\u2500\u2500 processor/\\n\u2502           \u251c\u2500\u2500 scheduler/\\n\u2502           \u251c\u2500\u2500 tasklet/\\n\u2502           \u2514\u2500\u2500 {project}Batch.kt\\n\u251c\u2500\u2500 {project}-core/\\n\u2502   \u2514\u2500\u2500 src/main/kotlin/{project}/core\\n\u251c\u2500\u2500 {project}-domain/\\n\u2502   \u2514\u2500\u2500 src/main/kotlin/{project}/domain\\n\u2502       \u2514\u2500\u2500 {domain}/\\n\u2502           \u251c\u2500\u2500 command/\\n\u2502           \u251c\u2500\u2500 entity/\\n\u2502           \u251c\u2500\u2500 exception/\\n\u2502           \u251c\u2500\u2500 query/\\n\u2502           \u251c\u2500\u2500 repository/\\n\u2502           \u251c\u2500\u2500 vo/\\n\u2502           \u251c\u2500\u2500 ${domain}Service.kt\\n\u2502           \u2514\u2500\u2500 ${domain}ServiceImpl.kt\\n\u251c\u2500\u2500 infra/\\n\u251c\u2500\u2500 Makefile\\n\u251c\u2500\u2500 build.gradle.kts\\n\u251c\u2500\u2500 gradle.properties\\n\u2514\u2500\u2500 settings.gradle.kts\\n```\\n\\n### .data/\\n\\nUsed as a volume-mounted data directory for Docker-based local infrastructure.\\nAll files and subdirectories are excluded from version control via .gitignore.\\n\\n### .docs/\\n\\nStores project-related documentation.\\nFiles such as `howto.md`, `structure.md`, `dictionary.md`, and `history.md` are created to ensure that the project can be easily understood even after some time has passed.\\n\\n### .infra/\\n\\nThis directory contains all configurations required to manage infrastructure as code.\\n\\n#### database/\\n\\nDatabase schema migrations are managed using Flyway under the `migrations` directory.\\nMigration file naming conventions are defined through Flyway configuration.\\n\\n```conf\\nflyway.sqlMigrationPrefix=v\\nflyway.sqlMigrationSeparator=__\\nflyway.sqlMigrationSuffixes=.sql\\n\\nflyway.baselineOnMigrate=true\\nflyway.baselineDescription=Initial baseline\\nflyway.baselineVersion=0.0.0\\nflyway.createSchemas=true\\nflyway.table=flyway_schema_history\\n```\\n\\n#### terraform/\\n\\nCloud infrastructure is managed using Terraform.\\nThe `environments/` directory contains environment-specific configurations, where `main.tf` defines the modules to be used and `variables.tf` declares required variables.\\n\\nReusable cloud service modules such as EC2, VPC, Security Group, and S3 are defined under the modules/ directory.\\n\\n#### docker-compose.yml\\n\\nManaged using Docker Compose to quickly provision and run required infrastructure in the local development environment.\\n\\n### gradle/\\n\\n#### libs.versions.toml\\n\\nUses Gradle Version Catalog to centrally manage versions of all libraries and plugins used across the project.\\n\\n```toml\\n[versions]\\nkotlin = \\"2.1.0\\"\\nspring-boot = \\"3.5.5\\"\\nspring-dependency-management = \\"1.1.7\\"\\nquerydsl = \\"7.0\\"\\nmockk = \\"1.14.5\\"\\nspringmockk = \\"4.0.2\\"\\nasciidoctor = \\"4.0.4\\"\\njjwt = \\"0.13.0\\"\\nkotlinx-coroutines = \\"1.7.3\\"\\nmapstruct = \\"1.6.3\\"\\n\\n[libraries]\\n# Spring Boot\\nspring-boot-starter-web = { module = \\"org.springframework.boot:spring-boot-starter-web\\", version.ref = \\"spring-boot\\" }\\nspring-boot-starter-batch = { module = \\"org.springframework.boot:spring-boot-starter-batch\\", version.ref = \\"spring-boot\\" }\\nspring-boot-starter-data-jpa = { module = \\"org.springframework.boot:spring-boot-starter-data-jpa\\", version.ref = \\"spring-boot\\" }\\nspring-boot-starter-mail = { module = \\"org.springframework.boot:spring-boot-starter-mail\\", version.ref = \\"spring-boot\\" }\\nspring-boot-starter-validation = { module = \\"org.springframework.boot:spring-boot-starter-validation\\", version.ref = \\"spring-boot\\" }\\nspring-boot-starter-actuator = { module = \\"org.springframework.boot:spring-boot-starter-actuator\\", version.ref = \\"spring-boot\\" }\\nspring-boot-starter-security = { module = \\"org.springframework.boot:spring-boot-starter-security\\", version.ref = \\"spring-boot\\" }\\nspring-boot-starter-test = { module = \\"org.springframework.boot:spring-boot-starter-test\\", version.ref = \\"spring-boot\\" }\\nspring-restdocs = { module = \\"org.springframework.restdocs:spring-restdocs-mockmvc\\", version = \\"3.0.5\\" }\\nspring-restdocs-asciidoctor = { module = \\"org.springframework.restdocs:spring-restdocs-asciidoctor\\", version = \\"3.0.5\\" }\\n\\n# Kotlin\\n#kotlin-stdlib = { module = \\"org.jetbrains.kotlin:kotlin-stdlib\\", version.ref = \\"kotlin\\" }\\nkotlin-reflect = { module = \\"org.jetbrains.kotlin:kotlin-reflect\\", version.ref = \\"kotlin\\" }\\n#kotlinx-coroutines-core = { module = \\"org.jetbrains.kotlinx:kotlinx-coroutines-core\\", version.ref = \\"kotlinx-coroutines\\" }\\n#kotlinx-coroutines-reactor = { module = \\"org.jetbrains.kotlinx:kotlinx-coroutines-reactor\\", version.ref = \\"kotlinx-coroutines\\" }\\n\\n# Jackson\\njackson-module-kotlin = { module = \\"com.fasterxml.jackson.module:jackson-module-kotlin\\" }\\n\\n# Database\\npostgresql = { module = \\"org.postgresql:postgresql\\", version = \\"42.7.7\\" }\\n\\n# QueryDSL\\nquerydsl-core = { module = \\"io.github.openfeign.querydsl:querydsl-core\\", version.ref = \\"querydsl\\" }\\nquerydsl-jpa = { module = \\"io.github.openfeign.querydsl:querydsl-jpa\\", version.ref = \\"querydsl\\" }\\nquerydsl-apt = { module = \\"io.github.openfeign.querydsl:querydsl-apt\\", version.ref = \\"querydsl\\" }\\n\\n# OAuth\\ngoogle-oauth = { module = \\"com.google.auth:google-auth-library-oauth2-http\\", version = \\"1.38.0\\" }\\ngoogle-api-client = { module = \\"com.google.api-client:google-api-client\\", version = \\"2.8.1\\" }\\n\\n# JWT\\njwt-api = { module = \\"io.jsonwebtoken:jjwt-api\\", version.ref = \\"jjwt\\" }\\njwt-impl = { module = \\"io.jsonwebtoken:jjwt-impl\\", version.ref = \\"jjwt\\" }\\njwt-jackson = { module = \\"io.jsonwebtoken:jjwt-jackson\\", version.ref = \\"jjwt\\" }\\n\\n# Mapstruct\\nmapstruct = { module = \\"org.mapstruct:mapstruct\\", version.ref = \\"mapstruct\\" }\\nmapstruct-processor = { module = \\"org.mapstruct:mapstruct-processor\\", version.ref = \\"mapstruct\\" }\\n\\n# ETC\\nuuid = { module = \\"com.fasterxml.uuid:java-uuid-generator\\", version = \\"5.1.0\\" }\\n\\n# Test\\nkotlin-test-junit5 = { module = \\"org.jetbrains.kotlin:kotlin-test-junit5\\" }\\nmockk = { module = \\"io.mockk:mockk\\", version.ref = \\"mockk\\" }\\nspringmockk = { module = \\"com.ninja-squad:springmockk\\", version.ref = \\"springmockk\\" }\\njunit-platform-launcher = { module = \\"org.junit.platform:junit-platform-launcher\\" }\\n\\n[bundles]\\nspring-web = [\\"spring-boot-starter-web\\", \\"spring-boot-starter-validation\\", \\"jackson-module-kotlin\\"]\\nspring-batch = [\\"spring-boot-starter-batch\\"]\\nspring-security = [\\"spring-boot-starter-security\\"]\\nhealth-check = [\\"spring-boot-starter-actuator\\"]\\nkotlin-base = [\\"kotlin-reflect\\"]\\ntest = [\\"spring-boot-starter-test\\", \\"kotlin-test-junit5\\", \\"mockk\\", \\"springmockk\\"]\\ninfra-rdbms = [\\"spring-boot-starter-data-jpa\\", \\"querydsl-core\\", \\"querydsl-jpa\\"]\\njwt-runtime = [\\"jwt-impl\\", \\"jwt-jackson\\"]\\n\\n[plugins]\\nkotlin-jvm = { id = \\"org.jetbrains.kotlin.jvm\\", version.ref = \\"kotlin\\" }\\nkotlin-spring = { id = \\"org.jetbrains.kotlin.plugin.spring\\", version.ref = \\"kotlin\\" }\\nkotlin-jpa = { id = \\"org.jetbrains.kotlin.plugin.jpa\\", version.ref = \\"kotlin\\" }\\nkotlin-kapt = { id = \\"org.jetbrains.kotlin.kapt\\", version.ref = \\"kotlin\\" }\\nspring-boot = { id = \\"org.springframework.boot\\", version.ref = \\"spring-boot\\" }\\nspring-dependency-management = { id = \\"io.spring.dependency-management\\", version.ref = \\"spring-dependency-management\\" }\\nasciidoctor-jvm-convert = { id = \\"org.asciidoctor.jvm.convert\\", version.ref = \\"asciidoctor\\" }\\n```\\n\\n### \\\\{project}-api/\\n\\nPreviously, the Presentation Layer (Controller) and Application Layer (Facade) were managed in separate packages, each defining its own DTOs and mapping logic.\\n\\nHowever, as development progressed, I observed that this approach introduced excessive duplication of DTOs and mapping code.\\nIn many cases, Controllers and Facades handled nearly identical request and response data, making the structure costly to maintain.\\n\\nAs a result, the current structure simplifies this by allowing Controllers and Facades to share Request and Response DTOs.\\n\\n```text\\n# Previous\\n{project}-api/\\n\u2514\u2500\u2500 src/main/kotlin/{project}/api\\n        \u251c\u2500\u2500 controller/\\n        \u2502   \u2514\u2500\u2500 {path}/\\n        \u2502       \u251c\u2500\u2500 request/\\n        \u2502       \u2514\u2500\u2500 response/\\n        \u2514\u2500\u2500 facade/\\n            \u2514\u2500\u2500 {path}/\\n                \u251c\u2500\u2500 input/\\n                \u2514\u2500\u2500 output/\\n# Current\\n{project}-api/\\n\u2514\u2500\u2500 src/main/kotlin/{project}/api\\n        \u2514\u2500\u2500 {path}/\\n            \u251c\u2500\u2500 request/\\n            \u2514\u2500\u2500 response/\\n```\\n\\n#### common\\n\\nManages components and objects shared across multiple modules, such as Filters, Exception Handlers, DTOs, and configuration properties.\\n\\n#### Mapping\\n\\nIn earlier Java-based Spring Boot projects, DTO mappings were handled using MapStruct with separate Mapper classes for each layer.\\nAfter transitioning to Kotlin Spring Boot, MapStruct often caused unclear mapping relationships and frequent compile-time or runtime errors, reducing its overall usability.\\n\\nCurrently, DTO mapping is handled using Kotlin extension functions, which are declared as `private` to limit their scope.\\nThe naming convention for mapping functions follows the pattern `to{TargetDtoName}`.\\n\\n```kotlin\\n// MARK: - example\\nprivate fun CreateUserRequest.toCreateUserCommand() = CreateUserCommand(\\n    email = this.email,\\n    name = this.name,\\n)\\n```\\n\\n### \\\\{project}-batch/\\n\\nAll packages, except common, define components strictly according to their directory name and responsibility.\\n\\n#### common/\\n\\nContains shared Job configurations and Listener configurations used across batch jobs.\\n\\n### \\\\{project}-domain/\\n\\nPreviously, infrastructure modules (e.g., rdbms, redis, mongodb) were separated under an infra module and implemented by the domain module.\\n\\nHowever, without a fully separated domain boundary, this approach increased complexity without providing sufficient benefits.\\nTherefore, the current design keeps infrastructure-related configurations within the domain module, with the intention of extracting them into separate modules once the service grows in size.\\n\\nThe `command` and `query` packages store DTOs for data mutation and data retrieval, respectively.\\nFile naming follows the conventions `{name}Command.kt` and `{name}Query.kt`.\\n\\nThe entity package contains database entities, while the `vo` package stores enums and Value Objects used within entities.\\n\\n### Makefile\\n\\nCentralizes frequently used commands such as starting and stopping Docker-based local infrastructure and executing Flyway schema migrations.\\n\\n```Makefile\\n# Environment Variables\\ninclude .env\\nexport\\n\\n# Get absolute project path\\nPROJECT_ROOT := $(shell pwd)\\nINFRA_PATH := $(PROJECT_ROOT)/.infra\\nDATABASE_PATH := $(PROJECT_ROOT)/.infra/database\\nMIGRATIONS_PATH := $(DATABASE_PATH)/migrations\\nVOLUME_PATH := $(PROJECT_ROOT)/.data\\n\\n# Environment file selection\\nENV ?= local\\nENV_FILE := $(PROJECT_ROOT)/.infra/env/.env.$(ENV)\\n\\n# Load environment-specific file if exists\\nifneq (,$(wildcard $(ENV_FILE)))\\n\\tinclude $(ENV_FILE)\\n\\texport\\nendif\\n\\n.PHONY: help env-* flyway-* container-*\\n\\nhelp: ## Show this help message\\n\\t@echo \\"\ud83d\udd27 Available Commands:\\"\\n\\t@echo \\"=====================\\"\\n\\t@awk \'BEGIN {FS = \\":.*?## \\"; printf \\"\\\\n\\"} /^[a-zA-Z_-]+:.*?## / {printf \\"  \\\\033[36m%-20s\\\\033[0m %s\\\\n\\", $$1, $$2}\' $(MAKEFILE_LIST)\\n\\t@echo \\"\\"\\n\\t@echo \\"\ud83d\udcdd Usage Examples:\\"\\n\\t@echo \\"  make help                    # Show this help\\"\\n\\t@echo \\"  make env-show               # Show current environment\\"\\n\\t@echo \\"  make container-up           # Start services\\"\\n\\t@echo \\"  make ENV=prod container-up  # Start services with production config\\"\\n\\t@echo \\"\\"\\n\\t@echo \\"\ud83c\udf0d Available Environments:\\"\\n\\t@echo \\"  local (default), dev, prod\\"\\n\\n\\nenv-show: ## Show current environment variables\\n\\t@echo \\"\ud83d\udccb Current Environment Variables:\\"\\n\\t@echo \\"=================================\\"\\n\\t@echo \\"Environment: $(ENV)\\"\\n\\t@echo \\"Project Root: $(PROJECT_ROOT)\\"\\n\\t@echo \\"DB Host: $(DB_HOST)\\"\\n\\t@echo \\"DB Name: $(DB_NAME)\\"\\n\\t@echo \\"Migrations Path: $(MIGRATIONS_PATH)\\"\\n\\t@echo \\"Database Path Path: $(DATABASE_PATH)\\"\\n\\t@echo \\"Volume Path: $(VOLUME_PATH)\\"\\n\\nenv-validate: ## Validate required environment variables\\n\\t@echo \\"\ud83d\udd0d Validating environment variables...\\"\\n\\t@test -n \\"$(DB_HOST)\\" || (echo \\"\u274c DB_HOST not set\\" && exit 1)\\n\\t@test -n \\"$(DB_NAME)\\" || (echo \\"\u274c DB_NAME not set\\" && exit 1)\\n\\t@test -n \\"$(DB_USERNAME)\\" || (echo \\"\u274c DB_USERNAME not set\\" && exit 1)\\n\\t@test -n \\"$(DB_PASSWORD)\\" || (echo \\"\u274c DB_PASSWORD not set\\" && exit 1)\\n\\t@test -d \\"$(MIGRATIONS_PATH)\\" || (echo \\"\u274c Migrations directory not found: $(MIGRATIONS_PATH)\\" && exit 1)\\n\\t@test -d \\"$(DATABASE_PATH)\\" || (echo \\"\u274c Database directory not found: $(DATABASE_PATH)\\" && exit 1)\\n\\t@test -d \\"$(VOLUME_PATH)\\" || (echo \\"\u274c Volume path not found: $(VOLUME_PATH)\\" && exit 1)\\n\\t@echo \\"\u2705 All required variables are set!\\"\\n\\nvolume-init: ## Initialize volume directories\\n\\t@mkdir $(VOLUME_PATH)\\n\\t@mkdir $(VOLUME_PATH)/postgresql\\n\\t@mkdir $(VOLUME_PATH)/redis\\n\\t@echo \\"\u2705 Volume directories created!\\"\\n\\n\\n# Container runtime detection and variables\\nCONTAINER_RUNTIME ?= $(shell which podman >/dev/null && echo podman || echo docker)\\n\\n# Container up\\ncontainer-up: ## Start services with container runtime\\n\\t@echo \\"\ud83d\udc33 Starting services with $(CONTAINER_RUNTIME) ($(ENV))...\\"\\n\\t@$(CONTAINER_RUNTIME) compose \\\\\\n\\t\\t--env-file $(ENV_FILE) \\\\\\n\\t\\t-f $(INFRA_PATH)/docker-compose.yml \\\\\\n\\t\\t-p $(PROJECT) \\\\\\n\\t\\tup -d\\n\\n# Container down\\ncontainer-down: ## Stop all services\\n\\t@echo \\"\ud83d\uded1 Stopping services with $(CONTAINER_RUNTIME) ($(ENV))...\\"\\n\\t@$(CONTAINER_RUNTIME) compose \\\\\\n\\t\\t-f $(INFRA_PATH)/docker-compose.yml \\\\\\n\\t\\t-p $(PROJECT) \\\\\\n\\t\\tdown\\n\\ncontainer-clean: ## Clean volumes and reinitialize\\n\\t@rm -rf $(VOLUME_PATH)\\n\\t@$(MAKE) volume-init\\n\\t@echo \\"\u2705 Volumes cleaned and reinitialized!\\"\\n\\nflyway-migrate: ## Run database migrations\\n\\t@echo $(DATABASE_PATH)/flyway.local.conf\\n\\t@$(CONTAINER_RUNTIME) run --rm \\\\\\n    \\t\\t--network host \\\\\\n    \\t\\t-v $(MIGRATIONS_PATH):/flyway/sql \\\\\\n    \\t\\t-v $(DATABASE_PATH)/flyway.$(ENV).conf:/flyway/conf/flyway.conf \\\\\\n    \\t\\t-e FLYWAY_URL=\\"$(FLYWAY_URL)\\" \\\\\\n            -e FLYWAY_USER=\\"$(FLYWAY_USER)\\" \\\\\\n            -e FLYWAY_PASSWORD=\\"$(FLYWAY_PASSWORD)\\" \\\\\\n    \\t\\t-e FLYWAY_SCHEMAS=\\"$(PROJECT)\\" \\\\\\n    \\t\\t-e FLYWAY_LOCATION=\\"$(MIGRATIONS_PATH)\\" \\\\\\n    \\t\\tflyway/flyway:11.11.2 \\\\\\n    \\t\\tmigrate\\n\\t@echo \\"\u2705 Database migrations completed!\\"\\n```"}]}}')}}]);